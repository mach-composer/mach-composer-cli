package generator

import (
	"context"
	"fmt"
	"github.com/mach-composer/mach-composer-cli/internal/config"
	"github.com/mach-composer/mach-composer-cli/internal/graph"
	"github.com/mach-composer/mach-composer-cli/internal/utils"
	"sort"
	"strings"
)

// renderSite is responsible for generating the `site.tf` file. Therefore, it is
// the main entrypoint for generating the terraform file for each site.
func renderSite(ctx context.Context, cfg *config.MachConfig, n *graph.Site) (string, error) {
	nestedNodes := n.NestedNodes

	result := []string{
		"# This file is auto-generated by MACH composer",
		fmt.Sprintf("# site: %s", n.Identifier()),
	}

	// Render the terraform config
	val, err := renderSiteTerraformConfig(cfg, n)
	if err != nil {
		return "", fmt.Errorf("failed to render terraform config: %w", err)
	}
	result = append(result, val)

	// Render all the file sources
	val, err = renderFileSources(cfg, n.SiteConfig)
	if err != nil {
		return "", fmt.Errorf("failed to render file sources: %w", err)
	}
	result = append(result, val)

	// Render all the global resources
	val, err = renderSiteResources(cfg, n)
	if err != nil {
		return "", fmt.Errorf("failed to render resources: %w", err)
	}
	result = append(result, val)

	sort.Slice(nestedNodes, func(i, j int) bool {
		return nestedNodes[i].Identifier() < nestedNodes[j].Identifier()
	})

	for _, component := range nestedNodes {
		if component.SiteComponentConfig.Deployment.Type != config.DeploymentSite {
			continue
		}
		val, err = renderComponentModule(ctx, cfg, component)
		if err != nil {
			return "", fmt.Errorf("failed to render site component: %w", err)
		}
		result = append(result, val)
	}

	return strings.Join(result, "\n"), nil
}

func renderSiteTerraformConfig(cfg *config.MachConfig, n *graph.Site) (string, error) {
	tpl, err := templates.ReadFile("templates/terraform.tmpl")
	if err != nil {
		return "", err
	}

	var providers []string
	for _, plugin := range cfg.Plugins.All() {
		content, err := plugin.RenderTerraformProviders(n.SiteConfig.Identifier)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render providers: %w", plugin.Name, err)
		}
		if content != "" {
			providers = append(providers, content)
		}
	}

	requirements, err := renderRequirements(cfg)
	if err != nil {
		return "", fmt.Errorf("failed to render requirements: %w", err)
	}
	providers = append(providers, requirements...)

	s, ok := cfg.StateRepository.Get(n.Identifier())
	if !ok {
		return "", fmt.Errorf("state repository does not have a backend for %s", n.Identifier())
	}

	b, err := s.Backend()
	if err != nil {
		return "", err
	}

	templateContext := struct {
		Providers     []string
		BackendConfig string
		IncludeSOPS   bool
	}{
		Providers:     providers,
		BackendConfig: b,
		IncludeSOPS:   cfg.Variables.HasEncrypted(n.SiteConfig.Identifier),
	}
	return utils.RenderGoTemplate(string(tpl), templateContext)
}

func renderSiteResources(cfg *config.MachConfig, n *graph.Site) (string, error) {
	tpl, err := templates.ReadFile("templates/resources.tmpl")
	if err != nil {
		return "", err
	}

	var resources []string
	for _, plugin := range cfg.Plugins.All() {
		content, err := plugin.RenderTerraformResources(n.SiteConfig.Identifier)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render resources: %w", plugin.Name, err)
		}

		if content != "" {
			resources = append(resources, content)
		}
	}

	providers, err := renderProviders(cfg)
	if err != nil {
		return "", fmt.Errorf("failed to render providers: %w", err)
	}
	resources = append(resources, providers...)

	return utils.RenderGoTemplate(string(tpl), resources)
}
